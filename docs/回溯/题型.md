## 78. 子集
给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。
解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var subsets = function (nums) {
    const res = [];
    const back = (path, i) => {
        if (path.length > nums.length) return;
        res.push(path);
        for (let j = i; j < nums.length; j++) {
            path.push(nums[j]);
            back(path.slice(), j + 1);
            path.pop();
        }
    };
    back([], 0);
    return res;
};
```

## 46. 全排列
给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function (nums) {
    const res = [];
    const back = (path, i) => {
        if (path.length === nums.length) {
            res.push(path);
        }
        for (let j = 0; j < nums.length; j++) {
            if (!path.includes(nums[j])) {
                path.push(nums[j]);
                back(path.slice(), j + 1);
                path.pop();
            }
        }
    };
    back([], 0);
    return res;
};
```

## 47. 全排列 II
给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permuteUnique = function (nums) {
    nums.sort((x, y) => x - y);
    const res = [];
    const visited = [];
    const back = (path) => {
        if (path.length === nums.length) {
            res.push(path);
            return;
        }
        for (let i = 0; i < nums.length; i++) {
            if (visited[i] || (!visited[i - 1] && nums[i] === nums[i - 1])) continue;
            path.push(nums[i]);
            visited[i] = true;
            back(path.slice());
            visited[i] = false;
            path.pop();
        }
    };
    back([]);
    return res;
};
```

## 39. 组合总和
给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
candidates 中的数字可以无限制重复被选取。

说明：
所有数字（包括 target）都是正整数。
解集不能包含重复的组合。 

```js
/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
var combinationSum = function (candidates, target) {
    const res = [];
    const back = (path, start) => {
        const sum = path.reduce((a, b) => a += b, 0);
        if (sum === target) res.push(path);
        for (let i = start; i < candidates.length; i++) {
            if (sum + candidates[i] > target) continue;
            path.push(candidates[i]);
            back(path.slice(), i);
            path.pop();
        }
    };
    back([], 0);
    return res;
};
```

## 40. 组合总和 II
给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
candidates 中的每个数字在每个组合中只能使用一次。
注意：解集不能包含重复的组合。 

```js
/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
var combinationSum2 = function(candidates, target) {
    candidates.sort((x, y) => x - y);
    const res = [];
    const visited = [];
    const back = (path, start) => {
        const sum = path.reduce((a, b) => a += b, 0);
        if (sum === target) res.push(path);
        for (let i = start; i < candidates.length; i++) {
            if (sum + candidates[i] > target || (candidates[i] === candidates[i - 1] && !visited[i - 1])) continue;
            path.push(candidates[i]);
            visited[i] = true;
            back(path.slice(), i + 1);
            path.pop();
            visited[i] = false;
        }
    };
    back([], 0);
    return res;
};
```

## 77. 组合
给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。

```js
/**
 * @param {number} n
 * @param {number} k
 * @return {number[][]}
 */
var combine = function (n, k) {
    const res = [];
    const back = (path, start) => {
        if (path.length === k) {
            res.push(path);
            return;
        }
        for (let i = start; i <= n; i++) {
            if (n - i + 1 < k - path.length) continue;
            path.push(i);
            back(path.slice(), i + 1);
            path.pop();
        }
    };
    back([], 1);
    return res;
};
```

## 784. 字母大小写全排列
给定一个字符串S，通过将字符串S中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。

```js
/**
 * @param {string} s
 * @return {string[]}
 */
var letterCasePermutation = function (s) {
    const res = [];
    const back = (path, index) => {
        if (path.length === s.length) {
            res.push(path);
            return;
        }
        const char = s[index];
        if (/[a-zA-Z]/.test(char)) {
            path += char.toLocaleLowerCase();
            back(path, index + 1);
            path = path.slice(0, path.length - 1);
        }
        path += char.toLocaleUpperCase();
        back(path, index + 1);
        path = path.slice(0, path.length - 1);
    };
    back('', 0);
    return res;
};
```

## 131. 分割回文串
给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。
回文串 是正着读和反着读都一样的字符串。

```js
/**
 * @param {string} s
 * @return {string[][]}
 */
var partition = function (s) {
    const res = [];
    const back = (path, i) => {
        if (i === s.length) {
            res.push(path);
        }
        for (let j = i; j < s.length; j++) {
            const str = s.slice(i, j + 1);
            if (str !== str.split('').reverse().join('')) continue;
            path.push(str);
            back(path.slice(), j + 1);
            path.pop();
        }
    };
    back([], 0);
    return res;
};
```

## 79. 单词搜索
给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。
单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

```js
/**
 * @param {character[][]} board
 * @param {string} word
 * @return {boolean}
 */
var exist = function (board, word) {
    let flag = false;
    const back = (m, n, count) => {
        if (count === word.length) return (flag = true);
        if (m > 0 && board[m - 1][n] === word[count]) {
            const cur = board[m][n];
            board[m][n] = '';
            back(m - 1, n, count + 1);
            board[m][n] = cur;
        }
        if (n > 0 && board[m][n - 1] === word[count]) {
            const cur = board[m][n];
            board[m][n] = '';
            back(m, n - 1, count + 1);
            board[m][n] = cur;
        }
        if (m < board.length - 1 && board[m + 1][n] === word[count]) {
            const cur = board[m][n];
            board[m][n] = '';
            back(m + 1, n, count + 1);
            board[m][n] = cur;
        }
        if (n < board[0].length - 1 && board[m][n + 1] === word[count]) {
            const cur = board[m][n];
            board[m][n] = '';
            back(m, n + 1, count + 1);
            board[m][n] = cur;
        }
    };
    for (let i = 0; i < board.length; i++) {
        for (let j = 0; j < board[0].length; j++) {
            if (board[i][j] === word[0]) {
                back(i, j, 1);
            }
        }
    }
    return flag;
};
```

## 51. N 皇后
n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。
给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。
每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。

```js
/**
 * @param {number} n
 * @return {string[][]}
 */
var solveNQueens = function (n) {
    const res = [];
    // 已摆放皇后的的列下标
    const columns = [];
    // 已摆放皇后的对角线1下标 左下 -> 右上
    // 计算某个坐标是否在这个对角线的方式是「行下标 + 列下标」是否相等
    const dia1 = [];
    // 已摆放皇后的对角线2下标 左上 -> 右下
    // 计算某个坐标是否在这个对角线的方式是「行下标 - 列下标」是否相等
    const dia2 = [];
    // 在选择当前的格子后 记录状态
    const record = (rowIndex, columnIndex, bool) => {
        columns[columnIndex] = bool;
        dia1[rowIndex + columnIndex] = bool;
        dia2[rowIndex - columnIndex] = bool;
    };
    // 尝试在一个n皇后问题中 摆放第index行内的皇后位置
    const putQueen = (rowIndex, prev) => {
        if (rowIndex === n) {
            res.push(generateBoard(prev));
            return;
        }
        // 尝试摆第index行的皇后 尝试[0, n-1]列
        for (let columnIndex = 0; columnIndex < n; columnIndex++) {
            // 在列上不冲突
            const columnNotConflict = !columns[columnIndex];
            // 在对角线1上不冲突
            const dia1NotConflict = !dia1[rowIndex + columnIndex];
            // 在对角线2上不冲突
            const dia2NotConflict = !dia2[rowIndex - columnIndex];
            if (columnNotConflict && dia1NotConflict && dia2NotConflict) {
                // 都不冲突的话，先记录当前已选位置，进入下一轮递归
                record(rowIndex, columnIndex, true);
                putQueen(rowIndex + 1, prev.concat(columnIndex));
                // 递归出栈后，在状态中清除这个位置的记录，下一轮循环应该是一个全新的开始。
                record(rowIndex, columnIndex, false);
            }
        }
    };
    putQueen(0, []);
    return res;
};

// 生成二维数组的辅助函数
function generateBoard(row) {
    const n = row.length;
    const res = [];
    for (let y = 0; y < n; y++) {
        let cur = '';
        for (let x = 0; x < n; x++) {
            if (x === row[y]) {
                cur += 'Q';
            } else {
                cur += '.';
            }
        }
        res.push(cur);
    }
    return res;
}
```