## 78. 子集
给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。
解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var subsets = function (nums) {
    const res = [];
    const back = (path, i) => {
        if (path.length > nums.length) return;
        res.push(path);
        for (let j = i; j < nums.length; j++) {
            path.push(nums[j]);
            back(path.slice(), j + 1);
            path.pop();
        }
    };
    back([], 0);
    return res;
};
```

## 46. 全排列
给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function (nums) {
    const res = [];
    const back = (path, i) => {
        if (path.length === nums.length) {
            res.push(path);
        }
        for (let j = 0; j < nums.length; j++) {
            if (!path.includes(nums[j])) {
                path.push(nums[j]);
                back(path.slice(), j + 1);
                path.pop();
            }
        }
    };
    back([], 0);
    return res;
};
```

## 39. 组合总和
给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
candidates 中的数字可以无限制重复被选取。

说明：
所有数字（包括 target）都是正整数。
解集不能包含重复的组合。 

```js
/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
var combinationSum = function (candidates, target) {
    const res = [];
    const back = (path, start) => {
        const sum = path.reduce((a, b) => a += b, 0);
        if (sum === target) res.push(path);
        for (let i = start; i < candidates.length; i++) {
            if (sum + candidates[i] > target) continue;
            path.push(candidates[i]);
            back(path.slice(), i);
            path.pop();
        }
    };
    back([], 0);
    return res;
};
```

## 131. 分割回文串
给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。
回文串 是正着读和反着读都一样的字符串。

```js
/**
 * @param {string} s
 * @return {string[][]}
 */
var partition = function (s) {
    const res = [];
    const back = (path, i) => {
        if (i === s.length) {
            res.push(path);
        }
        for (let j = i; j < s.length; j++) {
            const str = s.slice(i, j + 1);
            if (str !== str.split('').reverse().join('')) continue;
            path.push(str);
            back(path.slice(), j + 1);
            path.pop();
        }
    };
    back([], 0);
    return res;
};
```

## 79. 单词搜索
给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。
单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

```js
/**
 * @param {character[][]} board
 * @param {string} word
 * @return {boolean}
 */
var exist = function (board, word) {
    let flag = false;
    const back = (m, n, count) => {
        if (count === word.length) return (flag = true);
        if (m > 0 && board[m - 1][n] === word[count]) {
            const cur = board[m][n];
            board[m][n] = '';
            back(m - 1, n, count + 1);
            board[m][n] = cur;
        }
        if (n > 0 && board[m][n - 1] === word[count]) {
            const cur = board[m][n];
            board[m][n] = '';
            back(m, n - 1, count + 1);
            board[m][n] = cur;
        }
        if (m < board.length - 1 && board[m + 1][n] === word[count]) {
            const cur = board[m][n];
            board[m][n] = '';
            back(m + 1, n, count + 1);
            board[m][n] = cur;
        }
        if (n < board[0].length - 1 && board[m][n + 1] === word[count]) {
            const cur = board[m][n];
            board[m][n] = '';
            back(m, n + 1, count + 1);
            board[m][n] = cur;
        }
    };
    for (let i = 0; i < board.length; i++) {
        for (let j = 0; j < board[0].length; j++) {
            if (board[i][j] === word[0]) {
                back(i, j, 1);
            }
        }
    }
    return flag;
};
```
