## 78. 子集
给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。
解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var subsets = function (nums) {
    const res = [];
    const back = (path, i) => {
        if (path.length > nums.length) return;
        res.push(path);
        for (let j = i; j < nums.length; j++) {
            path.push(nums[j]);
            back(path.slice(), j + 1);
            path.pop();
        }
    };
    back([], 0);
    return res;
};
```

## 46. 全排列
给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function (nums) {
    const res = [];
    const back = (path, i) => {
        if (path.length === nums.length) {
            res.push(path);
        };
        for (let j = 0; j < nums.length; j++) {
            if (!path.includes(nums[j])) {
                path.push(nums[j]);
                back(path.slice(), j + 1);
                path.pop();
            }
        }
    };
    back([], 0);
    return res;
};
```

## 131. 分割回文串
给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。
回文串 是正着读和反着读都一样的字符串。

```js
/**
 * @param {string} s
 * @return {string[][]}
 */
var partition = function(s) {
    const res = [];
    const back = (path, i) => {
        if (i === s.length) {
            res.push(path);
        }
        for (let j = i; j < s.length; j++) {
            const str = s.slice(i, j + 1);
            if (str !== str.split('').reverse().join('')) continue;
            path.push(str);
            back(path.slice(), j + 1);
            path.pop();
        }
    }
    back([], 0);
    return res;
};
```
