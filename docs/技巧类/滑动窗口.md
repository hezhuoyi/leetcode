##  [209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)
给定一个含有 n 个正整数的数组和一个正整数 target 。

找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

```js
/**
 * @param {number} target
 * @param {number[]} nums
 * @return {number}
 */
let minSubArrayLen = function (target, nums) {
    let left = right = 0,sum = nums[0], res = Number.MAX_SAFE_INTEGER;
    while (right < nums.length) {
        if (sum >= target) {
            res = Math.min(res, right - left + 1)
            left++
            sum -= nums[left - 1]
        } else {
            do {
                right++
                sum += nums[right]
            } while (sum < target)
        }
    }
    return res === Number.MAX_SAFE_INTEGER ? 0 : res
};
```

## [76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)
给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。

```js
/**
 * @param {string} s
 * @param {string} t
 * @return {string}
 */
var minWindow = function (s, t) {
    let res = '';
    let left = right = needCount = 0;
    let map = {};
    let minLen = Number.MAX_SAFE_INTEGER;
    for (const char of t) {
        if (!map[char]) {
            map[char] = 1;
            needCount++;
        } else {
            map[char]++;
        }
    }
    while (right < s.length) {
        const rightChar = s[right];
        if (map[rightChar] !== undefined) map[rightChar]--;
        if (map[rightChar] === 0) needCount--;
        while (needCount === 0) {
            if (right - left + 1 < minLen) {
                minLen = right - left + 1;
                res = s.substring(left, right + 1);
            }
            const leftChar = s[left];
            if (map[leftChar] !== undefined) map[leftChar]++;
            if (map[leftChar] > 0) needCount++;
            left++;
        }
        right++;
    }
    return res;
};
```