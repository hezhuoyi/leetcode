## 98. 验证二叉搜索树
给定一个二叉树，判断其是否是一个有效的二叉搜索树。
假设一个二叉搜索树具有如下特征：
节点的左子树只包含小于当前节点的数。
节点的右子树只包含大于当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
// 分析：二叉搜索树的中序遍历是否为升序排列
// 递归 中序遍历
var isValidBST = function (root) {
    let min = -Infinity;
    const dfs = (node) => {
        if (!node) return true;
        // 一旦不符合条件立即返回 不再继续遍历
        if(!dfs(node.left)) return false;
        if (node.val <= min) return false;
        min = node.val;
        return dfs(node.right);
    };
    return dfs(root);
};

// 递归 优化版
var isValidBST = function (root) {
    const helper = (node, min, max) => {
        if (!node) return true;
        if (node.val <= min || node.val >= max) return false;
        // 将最后进入左子树的节点值 与 最后进入右子树的节点值 带入下一层递归
        return helper(node.left, min, node.val) && helper(node.right, node.val, max);
    };
    return helper(root, -Infinity, Infinity);
};

// 迭代 常规中序遍历
var isValidBST = function (root) {
    let min = -Infinity;
    let nodes = [];
    while (nodes.length || root) {
        while (root) {
            nodes.push(root);
            root = root.left;
        }
        const node = nodes.pop();
        if (node.val <= min) return false;
        min = node.val; // 将每个被访问的节点设为最小值
        root = node.right;
    }
    return true;
};
```

## 450. 删除二叉搜索树中的节点
给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。
一般来说，删除节点可分为两个步骤：
首先找到需要删除的节点；
如果找到了，删除它。
说明： 要求算法时间复杂度为 O(h)，h 为树的高度。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} key
 * @return {TreeNode}
 */
var deleteNode = function(root, key) {
    if (!root) return root;
    if (root.val > key) { // 从左子树找
        root.left = deleteNode(root.left, key);
    } else if (root.val < key) { // 从右子树找
        root.right = deleteNode(root.right, key);
    } else { // 找到该节点 分四种情况 1.无子节点 2.只有左子节点 3.只有右子节点 4.有左右两子节点
        if (!root.left && !root.right) {
            root = null; // 直接删除
        } else if (root.left && !root.right) {
            root = root.left; // 用左子树替代自己
        } else if (!root.left && root.right) {
            root = root.right; // 用右子树替代自己
        } else { // 将后继的最小值替换root的值
            let last = root.right;
            while (last.left) {
                last = last.left; // 找到后继的最小值的节点
            }
            root.val = last.val;
            root.right = deleteNode(root.right, last.val); // 最后删除这个后继最小值节点
            // 下面这种找到后继中小于root值的最大值也可以
            // let last = root.left;
            // while (last.right) {
            //     last = last.right;
            // }
            // root.val = last.val;
            // root.left = deleteNode(root.left, last.val);
        }
    }
    return root;
};
```