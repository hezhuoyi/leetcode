## 剑指 Offer 40. 最小的k个数
输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。

```js
/**
 * @param {number[]} arr
 * @param {number} k
 * @return {number[]}
 */
var getLeastNumbers = function (arr, k) {
    return arr.sort((a, b) => a - b).slice(0, k);
};
// 快排
var getLeastNumbers = function (arr, k) {
    if (!arr.length || !k) return [];
    let start = 0, end = arr.length - 1;
    let index = quickSort(arr, start, end);
    while (index !== k - 1) {
        if (index > k - 1) {
            // 上次查找的标杆位置大于目标位置
            end = index - 1;
        } else {
            // 上次查找的标杆位置小于目标位置
            start = index + 1;
        }
        index = quickSort(arr, start, end);
    }
    return arr.slice(0, k);
};
function quickSort(arr, left, right) {
    const pivot = arr[left];
    while (left < right) {
        while (left < right && arr[right] >= pivot) right--;
        arr[left] = arr[right];
        while (left < right && arr[left] < pivot) left++;
        arr[right] = arr[left];
    }
    arr[left] = pivot;
    return left;
}
```

## 面试题 10.01. 合并排序的数组
给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。
初始化 A 和 B 的元素数量分别为 m 和 n。
说明: A.length == n + m

```js
var merge = function (A, m, B, n) {
    while (n >= 1) {
        if (A[m - 1] >= B[n - 1]) {
            A[m + n - 1] = A[m - 1];
            m--;
        } else {
            A[m + n - 1] = B[n - 1];
            n--;
        }
    }
};
```

## 169. 多数元素
给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。
你可以假设数组是非空的，并且给定的数组总是存在多数元素。

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
// 排序法
var majorityElement = function (nums) {
    nums.sort((a, b) => a - b);
    return nums[Math.floor(nums.length / 2)];
};
// 哈希法
var majorityElement = function (nums) {
    const obj = {};
    for (let i = 0; i < nums.length; i++) {
        obj[nums[i]] = obj[nums[i]] ? ++obj[nums[i]] : 1;
        if (obj[nums[i]] > nums.length / 2) return nums[i];
    }
    return nums[0];
};
// 分治法
var majorityElement = function (nums) {
    const majorityElementRec = (start, end) => {
        if (start === end) return nums[start];
        const mid = Math.floor((start + end) / 2);
        const left = majorityElementRec(start, mid);
        const right = majorityElementRec(mid + 1, end);
        if (left === right) return left;
        let leftCount = 0;
        let rightCount = 0;
        for (let i = start; i <= mid; i++) {
            if (nums[i] === left) leftCount++;
        }
        for (let i = mid + 1; i <= end; i++) {
            if (nums[i] === right) rightCount++;
        }
        return leftCount > rightCount ? left : right;
    };
    return majorityElementRec(nums, 0, nums.length - 1);
};
```