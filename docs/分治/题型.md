## 剑指 Offer 40. 最小的k个数
输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。

```js
/**
 * @param {number[]} arr
 * @param {number} k
 * @return {number[]}
 */
var getLeastNumbers = function (arr, k) {
    return arr.sort((a, b) => a - b).slice(0, k);
};
// 快排
var getLeastNumbers = function (arr, k) {
    if (!arr.length || !k) return [];
    let start = 0, end = arr.length - 1;
    let index = quickSort(arr, start, end);
    while (index !== k - 1) {
        if (index > k - 1) {
            // 上次查找的标杆位置大于目标位置
            end = index - 1;
        } else {
            // 上次查找的标杆位置小于目标位置
            start = index + 1;
        }
        index = quickSort(arr, start, end);
    }
    return arr.slice(0, k);
};
function quickSort(arr, left, right) {
    const pivot = arr[left];
    while (left < right) {
        while (left < right && arr[right] >= pivot) right--;
        arr[left] = arr[right];
        while (left < right && arr[left] < pivot) left++;
        arr[right] = arr[left];
    }
    arr[left] = pivot;
    return left;
}
```

## 面试题 10.01. 合并排序的数组
给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。
初始化 A 和 B 的元素数量分别为 m 和 n。
说明: A.length == n + m

```js
var merge = function (A, m, B, n) {
    while (n >= 1) {
        if (A[m - 1] >= B[n - 1]) {
            A[m + n - 1] = A[m - 1];
            m--;
        } else {
            A[m + n - 1] = B[n - 1];
            n--;
        }
    }
};
```