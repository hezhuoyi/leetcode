## 70. 爬楼梯
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
注意：给定 n 是一个正整数。

```js
/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function (n) {
    const a = [0, 1, 2];
    for (let i = 3; i <= n; i++) {
        a[i] = a[i - 1] + a[i - 2];
    }
    return a[n];
};
```

## 198. 打家劫舍
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function (nums) {
    const dp = [];
    dp[0] = nums[0];
    dp[1] = Math.max(nums[0], nums[1] || 0);
    for (let i = 2; i < nums.length; i++) {
        dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);
    }
    return dp[nums.length - 1];
};
```

## 53. 最大子序和
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
// dp[n] = Math.max(dp[n−1] + nums[n], nums[n])
// 利用 pre 保存 dp[n−1] 即可
var maxSubArray = function (nums) {
    let pre = max = nums[0];
    for (let i = 1; i < nums.length; i++) {
        pre = pre > 0 ? pre + nums[i] : nums[i];
        max = Math.max(pre, max);
    }
    return max;
};
```
 
## 120. 三角形最小路径和
给定一个三角形 triangle ，找出自顶向下的最小路径和。
每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。

```js
/**
 * @param {number[][]} triangle
 * @return {number}
 */
var minimumTotal = function (triangle) {
    const m = triangle.length;
    const dp = [];
    dp[0] = [];
    dp[0][0] = triangle[0][0];
    if (m === 1) return dp[0][0];
    let min = Number.MAX_SAFE_INTEGER;
    for (let i = 1; i < m; i++) { // 第一列
        dp[i] = [];
        dp[i][0] = dp[i - 1][0] + triangle[i][0];
        if (i === m - 1) min = Math.min(min, dp[i][0]);
    }
    for (let i = 1; i < m; i++) {
        for (let j = 1; j < triangle[i].length; j++) {
            if (i === j) { // 每行最后一个元素 无 dp[i - 1][j]
                dp[i][j] = dp[i - 1][j - 1] + triangle[i][j];
            } else {
                dp[i][j] = Math.min(dp[i - 1][j], dp[i - 1][j - 1]) + triangle[i][j];
            }
            if (i === m - 1) min = Math.min(min, dp[i][j]);
        }
    }
    return min;
};

// 优化版 复用空间 自下向上
var minimumTotal = function (triangle) {
    for (let i = triangle.length - 2; i >= 0; i--) {
        for (let j = 0; j < triangle[i].length; j++) {
            triangle[i][j] = Math.min(triangle[i + 1][j], triangle[i + 1][j + 1]) + triangle[i][j];
        }
    }
    return triangle[0][0];
};
```

## 64. 最小路径和
给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
说明：每次只能向下或者向右移动一步。

```js
/**
 * @param {number[][]} grid
 * @return {number}
 */
var minPathSum = function (grid) {
    const m = grid.length, n = grid[0].length;
    const dp = [];
    for (let i = 0; i < m; i++) {
        dp[i] = [];
        for (let j = 0; j < n; j++) {
            if (i === 0 && j === 0) {
                dp[i][j] = grid[0][0];
            } else if (i === 0) {
                dp[i][j] = dp[i][j - 1] + grid[i][j];
            } else if (j === 0) {
                dp[i][j] = dp[i - 1][j] + grid[i][j];
            } else {
                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
            }
        }
    }
    return dp[m - 1][n - 1];
};
```

## 221. 最大正方形
在一个由 '0' 和 '1' 组成的二维矩阵内，找到只包含 '1' 的最大正方形，并返回其面积。

```js
/**
 * @param {character[][]} matrix
 * @return {number}
 */
var maximalSquare = function (matrix) {
    const m = matrix.length, n = matrix[0].length;
    let max = 0;
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            if (matrix[i][j] === '1') {
                matrix[i][j] = 1;
                if (i !== 0 && j !== 0) {
                    // 以右下角的点为中心 看三个相邻点为正方形右下角的边长情况
                    matrix[i][j] = Math.min(matrix[i - 1][j], matrix[i - 1][j - 1], matrix[i][j - 1]) + 1;
                }
            }
            max = Math.max(max, matrix[i][j]);
        }
    }
    return max * max;
};
```